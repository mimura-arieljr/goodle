import { SECRET_KEY } from "../libs/secrets.js";
// Generate a key from the password
const getKey = async () => {
    const keyMaterial = await crypto.subtle.importKey("raw", new TextEncoder().encode(SECRET_KEY), // Raw key material
    { name: "PBKDF2" }, // Use PBKDF2 to generate a derived key
    false, ["deriveKey"]);
    // Derive a key with PBKDF2 (you can use SHA-256 here, which gives a 256-bit key)
    const derivedKey = await crypto.subtle.deriveKey({
        name: "PBKDF2",
        salt: new TextEncoder().encode("some-salt"), // You should use a unique salt for each user
        iterations: 100000, // Increase iterations for better security
        hash: "SHA-256",
    }, keyMaterial, // The key material (password) you start with
    { name: "AES-GCM", length: 256 }, // AES-GCM with a 256-bit key
    false, ["encrypt", "decrypt"]);
    return derivedKey;
};
// Encrypt text
export const encryptText = async (plainText) => {
    const key = await getKey();
    const iv = new Uint8Array(12).fill(0); // A fixed IV (12 bytes of 0s)
    const encodedText = new TextEncoder().encode(plainText); // Convert text to byte array
    const encryptedText = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encodedText);
    // Return a base64-encoded string
    return btoa(String.fromCharCode(...iv) + String.fromCharCode(...new Uint8Array(encryptedText)));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nTWFuYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9zdHJpbmdNYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVoRCxtQ0FBbUM7QUFDbkMsTUFBTSxNQUFNLEdBQUcsS0FBSyxJQUFJLEVBQUU7SUFDdEIsTUFBTSxXQUFXLEdBQUcsTUFBTSxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FDN0MsS0FBSyxFQUNMLElBQUksV0FBVyxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLG1CQUFtQjtJQUN6RCxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsRUFBRSx1Q0FBdUM7SUFDM0QsS0FBSyxFQUNMLENBQUMsV0FBVyxDQUFDLENBQ2hCLENBQUM7SUFFRixpRkFBaUY7SUFDakYsTUFBTSxVQUFVLEdBQUcsTUFBTSxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FDNUM7UUFDSSxJQUFJLEVBQUUsUUFBUTtRQUNkLElBQUksRUFBRSxJQUFJLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSw2Q0FBNkM7UUFDMUYsVUFBVSxFQUFFLE1BQU0sRUFBRSwwQ0FBMEM7UUFDOUQsSUFBSSxFQUFFLFNBQVM7S0FDbEIsRUFDRCxXQUFXLEVBQUUsNkNBQTZDO0lBQzFELEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEVBQUUsNkJBQTZCO0lBQy9ELEtBQUssRUFDTCxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FDekIsQ0FBQztJQUVGLE9BQU8sVUFBVSxDQUFDO0FBQ3RCLENBQUMsQ0FBQztBQUVGLGVBQWU7QUFDZixNQUFNLENBQUMsTUFBTSxXQUFXLEdBQUcsS0FBSyxFQUFFLFNBQWlCLEVBQW1CLEVBQUU7SUFDcEUsTUFBTSxHQUFHLEdBQUcsTUFBTSxNQUFNLEVBQUUsQ0FBQztJQUMzQixNQUFNLEVBQUUsR0FBRyxJQUFJLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyw4QkFBOEI7SUFDckUsTUFBTSxXQUFXLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyw2QkFBNkI7SUFDdEYsTUFBTSxhQUFhLEdBQUcsTUFBTSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FDN0MsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUN2QixHQUFHLEVBQ0gsV0FBVyxDQUNkLENBQUM7SUFFRixpQ0FBaUM7SUFDakMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEcsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0VDUkVUX0tFWSB9IGZyb20gXCIuLi9saWJzL3NlY3JldHMuanNcIjtcblxuLy8gR2VuZXJhdGUgYSBrZXkgZnJvbSB0aGUgcGFzc3dvcmRcbmNvbnN0IGdldEtleSA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgICBcInJhd1wiLFxuICAgICAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoU0VDUkVUX0tFWSksIC8vIFJhdyBrZXkgbWF0ZXJpYWxcbiAgICAgICAgeyBuYW1lOiBcIlBCS0RGMlwiIH0sIC8vIFVzZSBQQktERjIgdG8gZ2VuZXJhdGUgYSBkZXJpdmVkIGtleVxuICAgICAgICBmYWxzZSwgXG4gICAgICAgIFtcImRlcml2ZUtleVwiXVxuICAgICk7XG5cbiAgICAvLyBEZXJpdmUgYSBrZXkgd2l0aCBQQktERjIgKHlvdSBjYW4gdXNlIFNIQS0yNTYgaGVyZSwgd2hpY2ggZ2l2ZXMgYSAyNTYtYml0IGtleSlcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiUEJLREYyXCIsXG4gICAgICAgICAgICBzYWx0OiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoXCJzb21lLXNhbHRcIiksIC8vIFlvdSBzaG91bGQgdXNlIGEgdW5pcXVlIHNhbHQgZm9yIGVhY2ggdXNlclxuICAgICAgICAgICAgaXRlcmF0aW9uczogMTAwMDAwLCAvLyBJbmNyZWFzZSBpdGVyYXRpb25zIGZvciBiZXR0ZXIgc2VjdXJpdHlcbiAgICAgICAgICAgIGhhc2g6IFwiU0hBLTI1NlwiLFxuICAgICAgICB9LFxuICAgICAgICBrZXlNYXRlcmlhbCwgLy8gVGhlIGtleSBtYXRlcmlhbCAocGFzc3dvcmQpIHlvdSBzdGFydCB3aXRoXG4gICAgICAgIHsgbmFtZTogXCJBRVMtR0NNXCIsIGxlbmd0aDogMjU2IH0sIC8vIEFFUy1HQ00gd2l0aCBhIDI1Ni1iaXQga2V5XG4gICAgICAgIGZhbHNlLFxuICAgICAgICBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXVxuICAgICk7XG5cbiAgICByZXR1cm4gZGVyaXZlZEtleTtcbn07XG5cbi8vIEVuY3J5cHQgdGV4dFxuZXhwb3J0IGNvbnN0IGVuY3J5cHRUZXh0ID0gYXN5bmMgKHBsYWluVGV4dDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBnZXRLZXkoKTtcbiAgICBjb25zdCBpdiA9IG5ldyBVaW50OEFycmF5KDEyKS5maWxsKDApOyAvLyBBIGZpeGVkIElWICgxMiBieXRlcyBvZiAwcylcbiAgICBjb25zdCBlbmNvZGVkVGV4dCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwbGFpblRleHQpOyAvLyBDb252ZXJ0IHRleHQgdG8gYnl0ZSBhcnJheVxuICAgIGNvbnN0IGVuY3J5cHRlZFRleHQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoXG4gICAgICAgIHsgbmFtZTogXCJBRVMtR0NNXCIsIGl2IH0sXG4gICAgICAgIGtleSxcbiAgICAgICAgZW5jb2RlZFRleHRcbiAgICApO1xuXG4gICAgLy8gUmV0dXJuIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gICAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5pdikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KGVuY3J5cHRlZFRleHQpKSk7XG59OyJdfQ==